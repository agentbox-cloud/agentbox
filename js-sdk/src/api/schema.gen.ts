/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/default-templates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description List all default templates */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Successfully returned all default templates */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Template"][];
                    };
                };
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
        };
        put?: never;
        /** @description Create a default template */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["DefaultTemplateRequest"];
                };
            };
            responses: {
                /** @description The default was accepted */
                202: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Template"];
                    };
                };
                400: components["responses"]["400"];
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/default-templates/{templateID}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description get an default template */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    templateID: components["parameters"]["templateID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description The build was accepted */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Template"];
                    };
                };
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
        };
        put?: never;
        post?: never;
        /** @description Delete a default template */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    templateID: components["parameters"]["templateID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description The default template was deleted successfully */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description List all running sandboxes */
        get: {
            parameters: {
                query?: {
                    /** @description Metadata query used to filter the sandboxes (e.g. "user=abc&app=prod"). Each key and values must be URL encoded. */
                    metadata?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Successfully returned all running sandboxes */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ListedSandbox"][];
                    };
                };
                400: components["responses"]["400"];
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
        };
        put?: never;
        /** @description Create a sandbox from the template */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["NewSandbox"];
                };
            };
            responses: {
                /** @description The sandbox was created successfully */
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Sandbox"];
                    };
                };
                400: components["responses"]["400"];
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxID}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get a sandbox by id */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    sandboxID: components["parameters"]["sandboxID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Successfully returned the sandbox */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["SandboxDetail"];
                    };
                };
                401: components["responses"]["401"];
                404: components["responses"]["404"];
                500: components["responses"]["500"];
            };
        };
        put?: never;
        post?: never;
        /** @description Kill a sandbox */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    sandboxID: components["parameters"]["sandboxID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description The sandbox was killed successfully */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                401: components["responses"]["401"];
                404: components["responses"]["404"];
                500: components["responses"]["500"];
            };
        };
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxID}/adb": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Sandbox adb link */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    sandboxID: components["parameters"]["sandboxID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Successfully returned the sandbox adb */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["SandboxADB"];
                    };
                };
                401: components["responses"]["401"];
                404: components["responses"]["404"];
                500: components["responses"]["500"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxID}/adb-public-info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Sandbox adb public info */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    sandboxID: components["parameters"]["sandboxID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Successfully returned the sandbox adb public info */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["SandboxADBPublicInfo"];
                    };
                };
                401: components["responses"]["401"];
                404: components["responses"]["404"];
                500: components["responses"]["500"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxID}/instance-auth-info": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Sandbox instance auth */
        get: {
            parameters: {
                query?: {
                    /** @description Whether the auth info can be used only once */
                    use_once?: boolean;
                    /** @description Valid time in seconds */
                    valid_time?: number;
                };
                header?: never;
                path: {
                    sandboxID: components["parameters"]["sandboxID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Successfully returned sandbox instance auth */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["InstanceAuthInfo"];
                    };
                };
                401: components["responses"]["401"];
                404: components["responses"]["404"];
                500: components["responses"]["500"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxID}/instance-no": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Sandbox instance number */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    sandboxID: components["parameters"]["sandboxID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Successfully returned sandbox instance number */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": string;
                    };
                };
                401: components["responses"]["401"];
                404: components["responses"]["404"];
                500: components["responses"]["500"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxID}/logs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get sandbox logs */
        get: {
            parameters: {
                query?: {
                    /** @description Maximum number of logs that should be returned */
                    limit?: number;
                    /** @description Starting timestamp of the logs that should be returned in milliseconds */
                    start?: number;
                };
                header?: never;
                path: {
                    sandboxID: components["parameters"]["sandboxID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Successfully returned the sandbox logs */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["SandboxLogs"];
                    };
                };
                401: components["responses"]["401"];
                404: components["responses"]["404"];
                500: components["responses"]["500"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxID}/metrics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get sandbox metrics */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    sandboxID: components["parameters"]["sandboxID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Successfully returned the sandbox metrics */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["SandboxMetric"][];
                    };
                };
                401: components["responses"]["401"];
                404: components["responses"]["404"];
                500: components["responses"]["500"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxID}/pause": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Pause the sandbox */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    sandboxID: components["parameters"]["sandboxID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description The sandbox was paused successfully and can be resumed */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                401: components["responses"]["401"];
                404: components["responses"]["404"];
                409: components["responses"]["409"];
                500: components["responses"]["500"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxID}/refreshes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Refresh the sandbox extending its time to live */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    sandboxID: components["parameters"]["sandboxID"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /** @description Duration for which the sandbox should be kept alive in seconds */
                        duration?: number;
                    };
                };
            };
            responses: {
                /** @description Successfully refreshed the sandbox */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                401: components["responses"]["401"];
                404: components["responses"]["404"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxID}/resume": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Resume the sandbox */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    sandboxID: components["parameters"]["sandboxID"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["ResumedSandbox"];
                };
            };
            responses: {
                /** @description The sandbox was resumed successfully */
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Sandbox"];
                    };
                };
                401: components["responses"]["401"];
                404: components["responses"]["404"];
                409: components["responses"]["409"];
                500: components["responses"]["500"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxID}/ssh": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Sandbox ssh link */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    sandboxID: components["parameters"]["sandboxID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Successfully returned the sandbox ssh */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["SandboxSSH"];
                    };
                };
                401: components["responses"]["401"];
                404: components["responses"]["404"];
                500: components["responses"]["500"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/{sandboxID}/timeout": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Set the timeout for the sandbox. The sandbox will expire x seconds from the time of the request. Calling this method multiple times overwrites the TTL, each time using the current timestamp as the starting point to measure the timeout duration. */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    sandboxID: components["parameters"]["sandboxID"];
                };
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": {
                        /**
                         * Format: int32
                         * @description Timeout in seconds from the current time after which the sandbox should expire
                         */
                        timeout: number;
                    };
                };
            };
            responses: {
                /** @description Successfully set the sandbox timeout */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                401: components["responses"]["401"];
                404: components["responses"]["404"];
                500: components["responses"]["500"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/sandboxes/metrics": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description List all running sandboxes with metrics */
        get: {
            parameters: {
                query?: {
                    /** @description Metadata query used to filter the sandboxes (e.g. "user=abc&app=prod"). Each key and values must be URL encoded. */
                    metadata?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Successfully returned all running sandboxes with metrics */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["RunningSandboxWithMetrics"][];
                    };
                };
                400: components["responses"]["400"];
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/templates": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description List all templates */
        get: {
            parameters: {
                query?: {
                    teamID?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Successfully returned all templates */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Template"][];
                    };
                };
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
        };
        put?: never;
        /** @description Create a new template */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["TemplateBuildRequest"];
                };
            };
            responses: {
                /** @description The build was accepted */
                202: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Template"];
                    };
                };
                400: components["responses"]["400"];
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/templates/{templateID}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Rebuild an template */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    templateID: components["parameters"]["templateID"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["TemplateBuildRequest"];
                };
            };
            responses: {
                /** @description The build was accepted */
                202: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Template"];
                    };
                };
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
        };
        /** @description Delete a template */
        delete: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    templateID: components["parameters"]["templateID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description The template was deleted successfully */
                204: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
        };
        options?: never;
        head?: never;
        /** @description Update template */
        patch: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    templateID: components["parameters"]["templateID"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["TemplateUpdateRequest"];
                };
            };
            responses: {
                /** @description The template was updated successfully */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                400: components["responses"]["400"];
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
        };
        trace?: never;
    };
    "/templates/{templateID}/builds/{buildID}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Start the build */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    buildID: components["parameters"]["buildID"];
                    templateID: components["parameters"]["templateID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description The build has started */
                202: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/templates/{templateID}/builds/{buildID}/agentbox/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get template build info */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    buildID: components["parameters"]["buildID"];
                    templateID: components["parameters"]["templateID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Successfully returned the template */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["AgentBoxTemplateBuild"];
                    };
                };
                401: components["responses"]["401"];
                404: components["responses"]["404"];
                500: components["responses"]["500"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/templates/{templateID}/builds/{buildID}/resource/upload": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description Upload resource archive to S3 for template build */
        post: {
            parameters: {
                query?: never;
                header: {
                    /** @description Name of the file to be uploaded to S3 */
                    "X-Object-Name": string;
                };
                path: {
                    buildID: components["parameters"]["buildID"];
                    templateID: components["parameters"]["templateID"];
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/octet-stream": string;
                };
            };
            responses: {
                /** @description Upload accepted and started */
                202: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content?: never;
                };
                400: components["responses"]["400"];
                401: components["responses"]["401"];
                404: components["responses"]["404"];
                500: components["responses"]["500"];
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/templates/{templateID}/builds/{buildID}/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Get template build info */
        get: {
            parameters: {
                query?: {
                    /** @description Index of the starting build log that should be returned with the template */
                    logsOffset?: number;
                };
                header?: never;
                path: {
                    buildID: components["parameters"]["buildID"];
                    templateID: components["parameters"]["templateID"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Successfully returned the template */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["TemplateBuild"];
                    };
                };
                401: components["responses"]["401"];
                404: components["responses"]["404"];
                500: components["responses"]["500"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v2/sandboxes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description List all sandboxes */
        get: {
            parameters: {
                query?: {
                    /** @description Maximum number of items to return per page */
                    limit?: number;
                    /** @description Metadata query used to filter the sandboxes (e.g. "user=abc&app=prod"). Each key and values must be URL encoded. */
                    metadata?: string;
                    /** @description Cursor to start the list from */
                    nextToken?: string;
                    /** @description Filter sandboxes by one or more states */
                    state?: components["schemas"]["SandboxState"][];
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Successfully returned all running sandboxes */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ListedSandbox"][];
                    };
                };
                400: components["responses"]["400"];
                401: components["responses"]["401"];
                500: components["responses"]["500"];
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        AccessTokenResponse: {
            /** @description Access token */
            access_token: string;
            /**
             * Format: int64
             * @description Expires_at
             */
            expires_at: number;
            /**
             * Format: int
             * @description Ixpires in
             */
            expires_in: number;
            /** @description Provider refresh token */
            provider_refresh_token: string;
            /** @description Provider token */
            provider_token: string;
            /** @description Refresh token */
            refresh_token: string;
            /** @description Token type */
            token_type: string;
            /** @description User */
            user: Record<string, never>;
            /** @description Weak password */
            weak_password: Record<string, never>;
        };
        AgentBoxTemplateBuild: {
            /** @description Identifier of the build */
            buildID: string;
            /**
             * @description Build logs
             * @default string
             */
            logs: string;
            /**
             * @description Status of the template
             * @enum {string}
             */
            status: "building" | "waiting" | "ready" | "error";
            /** @description Identifier of the template */
            templateID: string;
        };
        AuthUser: {
            /** @description email */
            email: string;
            /** @description id of the user */
            id: string;
        };
        CLILoginResponse: {
            /** @description Access token */
            access_token: string;
            /** @description Email */
            email: string;
            /** @description Team api key */
            team_api_key: string;
            /** @description Team id */
            team_id: string;
            /** @description Team name */
            team_name: string;
        };
        /**
         * Format: int32
         * @description CPU cores for the sandbox
         */
        CPUCount: number;
        CreatedAccessToken: {
            /**
             * Format: date-time
             * @description Timestamp of access token creation
             */
            createdAt: string;
            /**
             * Format: uuid
             * @description Identifier of the access token
             */
            id: string;
            mask: components["schemas"]["IdentifierMaskingDetails"];
            /** @description Name of the access token */
            name: string;
            /** @description The fully created access token */
            token: string;
        };
        CreatedTeamAPIKey: {
            /**
             * Format: date-time
             * @description Timestamp of API key creation
             */
            createdAt: string;
            createdBy?: components["schemas"]["TeamUser"] | null;
            /**
             * Format: uuid
             * @description Identifier of the API key
             */
            id: string;
            /** @description Raw value of the API key */
            key: string;
            /**
             * Format: date-time
             * @description Last time this API key was used
             */
            lastUsed?: string | null;
            mask: components["schemas"]["IdentifierMaskingDetails"];
            /** @description Name of the API key */
            name: string;
        };
        DefaultTemplateRequest: {
            /** @description Description for the template */
            description: string;
            /** @description ID the template */
            templateID: string;
        };
        /**
         * @description Type of the env
         * @enum {string}
         */
        EnvType: "linux_arm64" | "linux_x86" | "android";
        EnvVars: {
            [key: string]: string;
        };
        Error: {
            /**
             * Format: int32
             * @description Error code
             */
            code: number;
            /** @description Error */
            message: string;
        };
        IdentifierMaskingDetails: {
            /** @description Prefix used in masked version of the token or key */
            maskedValuePrefix: string;
            /** @description Suffix used in masked version of the token or key */
            maskedValueSuffix: string;
            /** @description Prefix that identifies the token or key type */
            prefix: string;
            /** @description Length of the token or key */
            valueLength: number;
        };
        InstanceAuthInfo: {
            /** @description tmp access key */
            accessKey: string;
            /** @description tmp access secret key */
            accessSecretKey: string;
            /** @description expire time for ak and sk */
            expireTime: string;
            /** @description instance number */
            instanceNo: string;
            /** @description user id */
            userId: string;
        };
        ListedSandbox: {
            /** @description Alias of the template */
            alias?: string;
            /** @description Identifier of the client */
            clientID: string;
            cpuCount: components["schemas"]["CPUCount"];
            /**
             * Format: date-time
             * @description Time when the sandbox will expire
             */
            endAt: string;
            memoryMB: components["schemas"]["MemoryMB"];
            metadata?: components["schemas"]["SandboxMetadata"];
            /** @description Identifier of the sandbox */
            sandboxID: string;
            /**
             * Format: date-time
             * @description Time when the sandbox was started
             */
            startedAt: string;
            state: components["schemas"]["SandboxState"];
            /** @description Identifier of the template from which is the sandbox created */
            templateID: string;
        };
        /**
         * Format: int32
         * @description Memory for the sandbox in MB
         */
        MemoryMB: number;
        NewAccessToken: {
            /** @description Name of the access token */
            name: string;
        };
        NewSandbox: {
            /**
             * @description Automatically pauses the sandbox after the timeout
             * @default false
             */
            autoPause: boolean;
            envVars?: components["schemas"]["EnvVars"];
            metadata?: components["schemas"]["SandboxMetadata"];
            /** @description Secure all system communication with sandbox */
            secure?: boolean;
            /** @description Identifier of the required template */
            templateID: string;
            /**
             * Format: int32
             * @description Time to live for the sandbox in seconds.
             * @default 15
             */
            timeout: number;
        };
        NewTeamAPIKey: {
            /** @description Name of the API key */
            name: string;
        };
        Node: {
            /**
             * Format: int32
             * @description Number of allocated CPU cores
             */
            allocatedCPU: number;
            /**
             * Format: int32
             * @description Amount of allocated memory in MiB
             */
            allocatedMemoryMiB: number;
            /** @description Commit of the orchestrator */
            commit: string;
            /**
             * Format: uint64
             * @description Number of sandbox create fails
             */
            createFails: number;
            /** @description Identifier of the node */
            nodeID: string;
            /**
             * Format: int32
             * @description Number of sandboxes running on the node
             */
            sandboxCount: number;
            /**
             * Format: int
             * @description Number of starting Sandboxes
             */
            sandboxStartingCount: number;
            status: components["schemas"]["NodeStatus"];
            /** @description Version of the orchestrator */
            version: string;
        };
        NodeDetail: {
            /** @description List of cached builds id on the node */
            cachedBuilds: string[];
            /** @description Commit of the orchestrator */
            commit: string;
            /**
             * Format: uint64
             * @description Number of sandbox create fails
             */
            createFails: number;
            /** @description Identifier of the node */
            nodeID: string;
            /** @description List of sandboxes running on the node */
            sandboxes: components["schemas"]["ListedSandbox"][];
            status: components["schemas"]["NodeStatus"];
            /** @description Version of the orchestrator */
            version: string;
        };
        /**
         * @description Status of the node
         * @enum {string}
         */
        NodeStatus: "ready" | "draining" | "connecting" | "unhealthy";
        NodeStatusChange: {
            status: components["schemas"]["NodeStatus"];
        };
        /**
         * @description Type of the node
         * @enum {string}
         */
        NodeType: "board" | "nomad_x86" | "nomad_arm64";
        OauthCallbackParams: {
            /** @description google / github code */
            code: string;
            /** @description google / github */
            provider: string;
            /** @description redirect url */
            returnTo: string;
        };
        PasswordGrantParams: {
            /** @description Email of the user */
            email: string;
            /** @description Password of the user */
            password: string;
            /** @description Phone of the user */
            phone?: string;
        };
        RecoverParams: {
            /** @description email of the user */
            email: string;
            /** @description redirect url for reset password */
            return_to: string;
        };
        ResetPasswordParams: {
            /** @description Password reseted */
            password: string;
            /** @description Token for confirmation */
            token: string;
        };
        ResumedSandbox: {
            /**
             * @description Automatically pauses the sandbox after the timeout
             * @default false
             */
            autoPause: boolean;
            /**
             * Format: int32
             * @description Time to live for the sandbox in seconds.
             * @default 15
             */
            timeout: number;
        };
        RunningSandboxWithMetrics: {
            /** @description Alias of the template */
            alias?: string;
            /** @description Identifier of the client */
            clientID: string;
            cpuCount: components["schemas"]["CPUCount"];
            /**
             * Format: date-time
             * @description Time when the sandbox will expire
             */
            endAt: string;
            memoryMB: components["schemas"]["MemoryMB"];
            metadata?: components["schemas"]["SandboxMetadata"];
            metrics?: components["schemas"]["SandboxMetric"][];
            /** @description Identifier of the sandbox */
            sandboxID: string;
            /**
             * Format: date-time
             * @description Time when the sandbox was started
             */
            startedAt: string;
            /** @description Identifier of the template from which is the sandbox created */
            templateID: string;
        };
        Sandbox: {
            /** @description Alias of the template */
            alias?: string;
            /** @description Identifier of the client */
            clientID: string;
            /** @description Access token used for envd communication */
            envdAccessToken?: string;
            /** @description Version of the envd running in the sandbox */
            envdVersion: string;
            /** @description Identifier of the sandbox */
            sandboxID: string;
            /** @description Identifier of the template from which is the sandbox created */
            templateID: string;
        };
        SandboxADB: {
            /** @description Command of adb auth */
            adbAuthCommand: string;
            /** @description Password of instance */
            authPassword: string;
            /** @description Command of instance */
            connectCommand: string;
            /** @description Expire time of instance */
            expireTime: string;
            /** @description Command of forwarder */
            forwarderCommand: string;
            /** @description ID of instance */
            instanceNo: string;
        };
        SandboxADBPublicInfo: {
            /** @description IP or HOST of instance adb connection */
            adbIp: string;
            /**
             * Format: int32
             * @description Port of instance adb connection
             */
            adbPort: number;
            /** @description Expire time of instance */
            expireTime: string;
            /** @description ID of instance */
            instanceNo: string;
            /** @description PrivateKey to connect instance */
            privateKey: string;
            /** @description PublicKey to connect instance */
            publicKey: string;
        };
        SandboxDetail: {
            /** @description Alias of the template */
            alias?: string;
            /** @description Identifier of the client */
            clientID: string;
            cpuCount: components["schemas"]["CPUCount"];
            /**
             * Format: date-time
             * @description Time when the sandbox will expire
             */
            endAt: string;
            /** @description Access token used for envd communication */
            envdAccessToken?: string;
            /** @description Version of the envd running in the sandbox */
            envdVersion?: string;
            memoryMB: components["schemas"]["MemoryMB"];
            metadata?: components["schemas"]["SandboxMetadata"];
            /** @description Identifier of the sandbox */
            sandboxID: string;
            /**
             * Format: date-time
             * @description Time when the sandbox was started
             */
            startedAt: string;
            state: components["schemas"]["SandboxState"];
            /** @description Identifier of the template from which is the sandbox created */
            templateID: string;
        };
        /** @description Log entry with timestamp and line */
        SandboxLog: {
            /** @description Log line content */
            line: string;
            /**
             * Format: date-time
             * @description Timestamp of the log entry
             */
            timestamp: string;
        };
        SandboxLogs: {
            /** @description Logs of the sandbox */
            logs: components["schemas"]["SandboxLog"][];
        };
        SandboxMetadata: {
            [key: string]: string;
        };
        /** @description Metric entry with timestamp and line */
        SandboxMetric: {
            /**
             * Format: int32
             * @description Number of CPU cores
             */
            cpuCount: number;
            /**
             * Format: float
             * @description CPU usage percentage
             */
            cpuUsedPct: number;
            /**
             * Format: int64
             * @description Total memory in MiB
             */
            memTotalMiB: number;
            /**
             * Format: int64
             * @description Memory used in MiB
             */
            memUsedMiB: number;
            /**
             * Format: date-time
             * @description Timestamp of the metric entry
             */
            timestamp: string;
        };
        SandboxSSH: {
            /** @description Password of instance */
            authPassword: string;
            /** @description Command of instance */
            connectCommand: string;
            /** @description Expire time of instance */
            expireTime: string;
            /** @description ID of instance */
            instanceNo: string;
        };
        /**
         * @description State of the sandbox
         * @enum {string}
         */
        SandboxState: "running" | "paused";
        SignInWithOAuthParams: {
            /** @description github / google */
            provider: string;
            /** @description callback redirect url */
            returnTo: string;
        };
        SignInWithOAuthResponse: {
            /** @description url for redirect */
            url?: string;
        };
        SignupParams: {
            /** @description aud */
            aud?: string;
            /** @description channel */
            channel?: string;
            /** @description code_challenge */
            code_challenge?: string;
            /** @description code_challenge_method */
            code_challenge_method?: string;
            /** @description Map of data */
            data?: Record<string, never>;
            /** @description email of the user */
            email: string;
            /** @description Password of the user */
            password: string;
            /** @description phone of the user */
            phone?: string;
            /** @description provider */
            provider?: string;
            /** @description Url for email auth link */
            return_to?: string;
        };
        SignupResponse: {
            user: Record<string, never>;
        };
        Team: {
            /** @description API key for the team */
            apiKey: string;
            /** @description Whether the team is the default team */
            isDefault: boolean;
            /** @description Name of the team */
            name: string;
            /** @description Identifier of the team */
            teamID: string;
        };
        TeamAddRequest: {
            /** @description Name of the team */
            name?: string;
            /** @description URL of the profile picture for the team */
            profile_picture_url?: string;
            /** @description Identifier of the team */
            teamID?: string;
        };
        TeamAPIKey: {
            /**
             * Format: date-time
             * @description Timestamp of API key creation
             */
            createdAt: string;
            createdBy?: components["schemas"]["TeamUser"] | null;
            /**
             * Format: uuid
             * @description Identifier of the API key
             */
            id: string;
            /**
             * Format: date-time
             * @description Last time this API key was used
             */
            lastUsed?: string | null;
            mask: components["schemas"]["IdentifierMaskingDetails"];
            /** @description Name of the API key */
            name: string;
        };
        TeamUpdateRequest: {
            /** @description Name of the team */
            name?: string;
            /** @description URL of the profile picture for the team */
            profile_picture_url?: string;
            /** @description Identifier of the team */
            teamID?: string;
        };
        TeamUser: {
            /** @description Email of the user */
            email: string;
            /**
             * Format: uuid
             * @description Identifier of the user
             */
            id: string;
        };
        Template: {
            /** @description Aliases of the template */
            aliases?: string[];
            /**
             * Format: int32
             * @description Number of times the template was built
             */
            buildCount: number;
            /** @description Identifier of the last successful build for given template */
            buildID: string;
            cpuCount: components["schemas"]["CPUCount"];
            /**
             * Format: date-time
             * @description Time when the template was created
             */
            createdAt: string;
            createdBy: components["schemas"]["TeamUser"] | null;
            envType: components["schemas"]["EnvType"];
            /**
             * Format: date-time
             * @description Time when the template was last used
             */
            lastSpawnedAt: string;
            memoryMB: components["schemas"]["MemoryMB"];
            /** @description Whether the template is public or only accessible by the team */
            public: boolean;
            /**
             * Format: int64
             * @description Number of times the template was used
             */
            spawnCount: number;
            /** @description Identifier of the template */
            templateID: string;
            /**
             * Format: date-time
             * @description Time when the template was last updated
             */
            updatedAt: string;
        };
        TemplateBuild: {
            /** @description Identifier of the build */
            buildID: string;
            /**
             * @description Build logs
             * @default []
             */
            logs: string[];
            /**
             * @description Status of the template
             * @enum {string}
             */
            status: "building" | "waiting" | "ready" | "error";
            /** @description Identifier of the template */
            templateID: string;
        };
        TemplateBuildRequest: {
            /** @description Alias of the template */
            alias?: string;
            cpuCount?: components["schemas"]["CPUCount"];
            /** @description Dockerfile for the template */
            dockerfile: string;
            envType?: components["schemas"]["EnvType"];
            memoryMB?: components["schemas"]["MemoryMB"];
            /** @description Ready check command to execute in the template after the build */
            readyCmd?: string;
            /** @description Start command to execute in the template after the build */
            startCmd?: string;
            /** @description Identifier of the team */
            teamID?: string;
        };
        TemplateUpdateRequest: {
            /** @description Whether the template is public or only accessible by the team */
            public?: boolean;
        };
        UpdateTeamAPIKey: {
            /** @description New name for the API key */
            name: string;
        };
        User: {
            /** @description Email name */
            email?: string;
            /** @description Name of the user */
            name?: string;
            /** @description Map of data */
            user_metadata?: Record<string, never>;
        };
        UserTeamRelation: {
            /** @description Whether the team is the default team */
            isDefault?: boolean;
            /** @description Identifier of the team */
            teamID: string;
            /** @description User id */
            userID: string;
        };
        UserTeamRequest: {
            /** @description Email name */
            email: string;
            /** @description Whether the team is the default team */
            isDefault?: boolean;
            /** @description Identifier of the team */
            teamID: string;
        };
        UserUpdateRequest: {
            /** @description Email name */
            email?: string;
            /** @description Url for the redirect to verify */
            emailRedirectTo?: string;
            /** @description Name of the user */
            name?: string;
            /** @description Password of user account */
            password?: string;
        };
    };
    responses: {
        /** @description Bad request */
        400: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Authentication error */
        401: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Not found */
        404: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Conflict */
        409: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
        /** @description Server error */
        500: {
            headers: {
                [name: string]: unknown;
            };
            content: {
                "application/json": components["schemas"]["Error"];
            };
        };
    };
    parameters: {
        accessTokenID: string;
        apiKeyID: string;
        buildID: string;
        nodeID: string;
        sandboxID: string;
        teamID: string;
        templateID: string;
        userID: string;
    };
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
